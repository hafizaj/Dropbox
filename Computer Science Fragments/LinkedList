int subsequence(const Sequence& seq1, const Sequence& seq2)
{
	
}

seq: 15 8 20 12 31 18
seq2: 18 8 20 12 --> is a subsequence --> returns 0
seq3: 12 31 --> is a subsequence --> returns 3
seq2: 31 12 20 -->


void interleave(const Sequence& seq1, const Sequence& seq2, Sequence& result)

seq1 : 15 8 20
seq2 : 0  8 4
returns: 15, 0, 8, 8, 20, 4

seq1: 2  1. 10 11
seq2: 40 --> no more elements
returns 2, 40 , 1, 10 ,11


Linked List

struct Node{

	int value;
	Node* next;
	Node* prev; 
    
};


Node* head	=	nullptr;
Node* tail	=	nullptr;

Our linked list is empty

insertAtFront(int element)
{
	// We need to make a new node 
	Head is pointing to
}

4
head : null


Create a new node with int 8:

Initialize it so that we set the pointer prev: nullptr:
										 next: head;
Set head = head;


int findElement(const Node* head,const Node* tail, int element)
{
	int counter = 0;
	Node* p = head;
	for(; p != nullptr && p->val != element; p = p->next)
	{
		return
	}
}


=====================

Order of constructions
----------------------

1.	Arguments of the constructor : does any of the arguments to print anything
2.	Initialization list (All the private member list will be constructed if they have initialization list)
3.	


Pokemon pikacu("Pikachu",20,16,12);
the private member will be initialize using their initialization list.

Youre making a pikachu array


Pokemon m_pokemon[3];

Say destructed 

~Pokemon()
{
	cout << Pokemon destructed fainted. << endl;
}

Array has to be deleted


Order of destruction is the reverse of order of construction

What if ~Trainer()
{
	cout << m_pokemon[0].getName() << endl;
	delete starterPokemon();
	cout << "Game over for " << m_name << "!!!" << endl;
}
	
if the array of pokemon gets destructed before trainer is destructor , then the code above doesn't work


1. Linked List Rules

1. Never access a node's data vwithout first being 100% sure that it's valid.

	// move to next element in the list
	if (p != nullptr) // dereferencing a nullpointer . at runtime, the program crashes
	{
		p = p-> next;
	}

2. if you want to know that yoy're at the last element, check its next:

while ( p != nullptr && p-> next != nullptr) 


Implement two function on linked lists

1. Loop 

bool loop(Node* head)
{
	//singly linked list with no tail
	//no pointer there that goes to null
}

void pivot(Node* head, Node* tail,int pivot)
{
	all elements less than the pivot needs to be to the left, but not in any order
	all the elements greater than the pivot needs to be greater than the pivot.
}


bool loop(Node* head)
{
	
}

// If we current pointer points to an element which is smaller than the pivot, it places it to the front immediately.
// make sure it's not empty
// loop over the elements

while p != nullptr.
if val <= pivot, move to the front.

{
	/
	/
	/
	/
	/
	/
	/
	/
	/
}

//	move p forward.